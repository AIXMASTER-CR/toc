
# Initialization of the DFA

print(comma separated ip)

ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")
f = set(input("Enter the final states: ").split(","))
transitions = {}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        transitions[state][inp] = input(f"Enter the next state for {state} on input {inp}: ")

# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]

    for i in range(len(ip)):
        next=transitions[path[i]][ip[i]]
        path.append(next)

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    if path[-1] in f:
        print("\nInput accepted")
    else:
        print("\nInput rejected")

    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break






Mealy –



# Initialization of the Mealy machine
print(“comma separated ip”)

ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")

transitions = {}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        next_state = input(f"Enter next state for {state} on input {inp}: ")
        output = input(f"Enter output for {state} on input {inp}: ")
        transitions[state][inp] = (next_state, output)

# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]
    output_path = ""

    for i in range(len(ip)):
        next_state, output = transitions[path[i]][ip[i]]
        path.append(next_state)
        output_path += output

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    print("\nOutput sequence:", output_path)

    

    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break








MOORE

# Initialization of the MOORE machine
ns = set(input("Enter the states: ").split(","))
ni = set(input("Enter the inputs: ").split(","))
q = input("Enter the start state: ")

transitions = {}
outputs={}

for state in ns:
    transitions[state] = {}
    for inp in ni:
        next_state = input(f"Enter next state for {state} on input {inp}: ")
        transitions[state][inp] =next_state

for state in ns:
    outputs[state]=input(f" enter output for state {state} :")
# Main loop for validating strings
while True:
    ip = input("Enter the string to process: ")
    path = [q]
    output_path =outputs[q]

    for i in range(len(ip)):
        next_state= transitions[path[i]][ip[i]]
        path.append(next_state)
        output_path +=outputs[next_state]

    print("Path:")
    for i in range(len(ip)):
        print(f"{path[i]}-{ip[i]}-->", end=" ")

    print("\nOutput sequence:", output_path)

    
    choice = input("Do you want to validate another string? (y/n): ")
    if choice.lower() == "n":
        break









Dfa

class DFA:
    def __init__(self, starting_state, final_states, transitions):
        self.starting_state = starting_state
        self.final_states = final_states
        self.transitions = transitions

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state = current_state_transition.get(input_symbol)
                traversal_path.append(f"{input_symbol} -> {next_state}")
                current_state = next_state
            else:
                print("Output: Your string is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        if current_state in self.final_states:
            print("Output: Your string is valid")
        else:
            print("Output: Your string is not valid")
            print(f"Reason: Your string ends at state '{current_state}' which is not a final state")

        print("Traversal Path: " + " - ".join(traversal_path))


def main():
    message = "Enter valid input symbols (∑) (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    message = "Enter all final states (F) (comma-separated): "
    final_state_string = input(message)
    final_states = set(final_state_string.split(","))

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter transition (δ) for state '{state}' having input '{valid_input}': "
            next_state = input(message)
            transitions[state][valid_input] = next_state

    dfa = DFA(starting_state, final_states, transitions)

    while True:
        message = "Enter string to be validated: "
        input_sequence = input(message)
        dfa.process_input_sequence(input_sequence)

        choice = input("Do you want to validate another string? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()




Mealy

class MealyMachine:
    def __init__(self, starting_state, transitions):
        self.starting_state = starting_state
        self.transitions = transitions

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        output_sequence = ""
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state, output = current_state_transition[input_symbol]
                output_sequence += output
                traversal_path.append(f"{current_state}({input_symbol},{output})->{next_state}")
                current_state = next_state
            else:
                print("Output: Your input sequence is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        print("Output Sequence:", output_sequence)
        print("Traversal Path:", " -> ".join(traversal_path))


def main():
    message = "Enter valid input symbols (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter next state for transition '{state}' with input '{valid_input}': "
            next_state = input(message)
            message = f"Enter output for transition '{state}' with input '{valid_input}': "
            output = input(message)
            transitions[state][valid_input] = (next_state, output)

    mealy_machine = MealyMachine(starting_state, transitions)

    while True:
        message = "Enter input sequence to be processed: "
        input_sequence = input(message)
        mealy_machine.process_input_sequence(input_sequence)

        choice = input("Do you want to process another input sequence? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()




Moore


class MooreMachine:
    def __init__(self, starting_state, transitions, outputs):
        self.starting_state = starting_state
        self.transitions = transitions
        self.outputs = outputs

    def process_input_sequence(self, input_sequence):
        current_state = self.starting_state
        output_sequence = self.outputs[current_state]  # Include the initial state's output
        traversal_path = [current_state]

        for input_symbol in input_sequence:
            current_state_transition = self.transitions.get(current_state, {})
            if input_symbol in current_state_transition:
                next_state = current_state_transition[input_symbol]
                output_sequence += self.outputs[next_state]  # Get output associated with the next state
                traversal_path.append(f"{current_state}({input_symbol},{self.outputs[next_state]})->{next_state}")
                current_state = next_state
            else:
                print("Output: Your input sequence is not valid")
                print(f"Reason: Invalid transition: State '{current_state}' with input '{input_symbol}'")
                return

        print("Output Sequence:", output_sequence)
        print("Traversal Path:", " -> ".join(traversal_path))


def main():
    message = "Enter valid input symbols (comma-separated): "
    valid_input_string = input(message)
    valid_inputs = set(valid_input_string.split(","))

    message = "Enter states (Q) (comma-separated): "
    state_string = input(message)
    states = set(state_string.split(","))

    message = "Enter starting state (q0): "
    starting_state = input(message)

    outputs = {}  # Modify to store outputs associated with states

    for state in states:
        message = f"Enter output for state '{state}': "
        output = input(message)
        outputs[state] = output

    transitions = {}

    for state in states:
        transitions[state] = {}
        for valid_input in valid_inputs:
            message = f"Enter next state for transition '{state}' with input '{valid_input}': "
            next_state = input(message)
            transitions[state][valid_input] = next_state

    moore_machine = MooreMachine(starting_state, transitions, outputs)

    while True:
        message = "Enter input sequence to be processed: "
        input_sequence = input(message)
        moore_machine.process_input_sequence(input_sequence)

        choice = input("Do you want to process another input sequence? (y/n): ")
        if choice.lower() == "n":
            break


if __name__ == "__main__":
    main()







Cfg to pda

rules = [input().split() for _ in range(int(input("Enter number of production rules: ")))]

non_terminals = {rule[0] for rule in rules}
terminals = set()
for rule in rules:
    for prod in rule[1].split('|'):
        for ch in prod:
            if ch.islower() or ch.isdigit():
                terminals.add(ch)
terminals.add('#')

print("PDA Production Rules:")
for non_term in non_terminals:
    print(f"dl(q,null,{non_term}) --> ", end='')
    first = True
    for rule in rules:
        if rule[0] == non_term:
            for prod in rule[1].split('|'):
                if not first:
                    print(" | ", end='')
                print(f"dl(q,{prod})", end='')
                first = False
    print()

for term in terminals:
    if term == '#':
        print("dl(q,null,null) --> dl(q,null)")
    else:
        print(f"dl(q,{term},{term}) --> dl(q,null)")






Cfg to cnf

import string

def remove_char(string, pos):
    new_string = ""
    for i in range(len(string)):
        if str(i) not in pos:
            new_string += string[i]
    return new_string

from itertools import permutations

NT_symbol = input("Enter the NonTerminal Symbols: ").split(" ")
T_symbol = input("Enter the Terminal Symbols: ").split(" ")

main = {}

#Eliminating NULL Production
n = []
for i in NT_symbol:
    main[i] = input(i + " -> ").split("/")

for i in main:
    for k in main[i]:
        for u in k:
            if u=="^":
                n.append(i)
                break

n = [*set(n)]
for i in main:
    for k in main[i]:
        pos = ""
        m = []
        possible_comb = []

        for u in range(len(k)):
            if k[u] in n:
                    pos += str(u)

        for b in range(len(pos)):
            temp = [''.join(p) for p in permutations(pos, b + 1)]
            possible_comb = possible_comb + temp

        for b in possible_comb:
            new_k = k
            if k != "^":
                m.append(remove_char(k, b))
        main[i] = main[i] + list(set(m))
    main[i] = [production.replace('^', '') for production in main[i]]

# Removing unit productions
unit_prod = {}

for i in NT_symbol:
    unit_prod[i] = []

for i in main:
    for b in main[i]:
        if b in NT_symbol:
            unit_prod[i].append(b)

for i in unit_prod:
    for j in unit_prod[i]:
        for k in main[i]:
            if k == j:
                main[i].remove(k)

for i in unit_prod:
    for mt in unit_prod[i]:
                for k in main[mt]:
                    main[i].append(k)

print("\nAFTER REMOVING NULL AND UNIT PRODUCTION")
for i in main:
    print(i + " -> ", end="")
    for ele in range(len(main[i])):
        if(main[i][ele]!=""):
            b = main[i][ele]
            print(b, end="/")
    print()

print("\nConverting to CNF form: ")

letter = len(string.ascii_uppercase)

for sym in NT_symbol:
    for i in range(len(main[sym])):
        b = main[sym][i]
        count_NT = 0
        count_T = 0

        for j in b:
            if j.isupper():
                count_NT += 1
            elif j.islower():
                count_T += 1

        if count_NT == 3:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0:2]]
            main[sym][i] = New_NT + b[2]

        elif count_T == 1 and count_NT == 2:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT2 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT2)
            main[New_NT2] = [b[1:]]
            main[sym][i] = New_NT + New_NT2

        elif count_T == 1 and count_NT == 1:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            main[sym][i] = New_NT + b[1]
        
        elif count_T == 2 and count_NT == 1:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1+b[2]
            b=main[sym][i]
            New_NT2 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT2)
            main[New_NT2] = [b[0:2]]
            main[sym][i] = New_NT2+b[2]
        elif count_T == 2 and count_NT == 0:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1
        elif count_T == 2 and count_NT == 2:
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[1]]
            main[sym][i] = New_NT + New_NT1 + b[2:]
            
            b=main[sym][i]
            New_NT = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT)
            main[New_NT] = [b[0:2]]
            New_NT1 = string.ascii_uppercase[letter - 1]
            letter -= 1
            NT_symbol.append(New_NT1)
            main[New_NT1] = [b[2:]]
            main[sym][i] = New_NT + New_NT1


for i in main:
    print(i + " -> ", end="")
    unique_productions = set()
    for ele in range(len(main[i])):
        if main[i][ele] != "":
            b = main[i][ele]
            if b not in unique_productions:
                print(b, end="/")
                unique_productions.add(b)
    
    print()

    
    
    


Enfa


class Type:
    SYMBOL = 1
    CONCAT = 2
    UNION  = 3
    KLEENE = 4

class ExpressionTree:

    def __init__(self, _type, value=None):
        self._type = _type
        self.value = value
        self.left = None
        self.right = None
    

def constructTree(regexp):
    stack = []
    for c in regexp:
        if c.isalpha():
            stack.append(ExpressionTree(Type.SYMBOL, c))
        else:
            if c == "+":
                z = ExpressionTree(Type.UNION)
                z.right = stack.pop()
                z.left = stack.pop()
            elif c == ".":
                z = ExpressionTree(Type.CONCAT)
                z.right = stack.pop()
                z.left = stack.pop()
            elif c == "*":
                z = ExpressionTree(Type.KLEENE)
                z.left = stack.pop()
            stack.append(z)

    return stack[0]

def inorder(et):
    if et._type == Type.SYMBOL:
        print(et.value)
    elif et._type == Type.CONCAT:
        inorder(et.left)
        print(".")
        inorder(et.right)
    elif et._type == Type.UNION:
        inorder(et.left)
        print("+")
        inorder(et.right)
    elif et._type == Type.KLEENE:
        inorder(et.left)
        print("*")

def higherPrecedence(a, b):
    p = ["+", ".", "*"]
    return p.index(a) > p.index(b)

def postfix(regexp):
    # adding dot "." between consecutive symbols
    temp = []
    for i in range(len(regexp)):
        if i != 0\
            and (regexp[i-1].isalpha() or regexp[i-1] == ")" or regexp[i-1] == "*")\
            and (regexp[i].isalpha() or regexp[i] == "("):
            temp.append(".")
        temp.append(regexp[i])
    regexp = temp
    
    stack = []
    output = ""

    for c in regexp:
        if c.isalpha():
            output = output + c
            continue

        if c == ")":
            while len(stack) != 0 and stack[-1] != "(":
                output = output + stack.pop()
            stack.pop()
        elif c == "(":
            stack.append(c)
        elif c == "*":
            output = output + c
        elif len(stack) == 0 or stack[-1] == "(" or higherPrecedence(c, stack[-1]):
            stack.append(c)
        else:
            while len(stack) != 0 and stack[-1] != "(" and not higherPrecedence(c, stack[-1]):
                output = output + stack.pop()
            stack.append(c)

    while len(stack) != 0:
        output = output + stack.pop()

    return output

class FiniteAutomataState:
    def __init__(self):
        self.next_state = {}

def evalRegex(et):
    # returns equivalent E-NFA for given expression tree (representing a Regular
    # Expression)
    if et._type == Type.SYMBOL:
        return evalRegexSymbol(et)
    elif et._type == Type.CONCAT:
        return evalRegexConcat(et)
    elif et._type == Type.UNION:
        return evalRegexUnion(et)
    elif et._type == Type.KLEENE:
        return evalRegexKleene(et)

def evalRegexSymbol(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()
    
    start_state.next_state[et.value] = [end_state]
    return start_state, end_state

def evalRegexConcat(et):
    left_nfa  = evalRegex(et.left)
    right_nfa = evalRegex(et.right)

    left_nfa[1].next_state['epsilon'] = [right_nfa[0]]
    return left_nfa[0], right_nfa[1]

def evalRegexUnion(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()

    up_nfa   = evalRegex(et.left)
    down_nfa = evalRegex(et.right)

    start_state.next_state['epsilon'] = [up_nfa[0], down_nfa[0]]
    up_nfa[1].next_state['epsilon'] = [end_state]
    down_nfa[1].next_state['epsilon'] = [end_state]

    return start_state, end_state

def evalRegexKleene(et):
    start_state = FiniteAutomataState()
    end_state   = FiniteAutomataState()

    sub_nfa = evalRegex(et.left)

    start_state.next_state['epsilon'] = [sub_nfa[0], end_state]
    sub_nfa[1].next_state['epsilon'] = [sub_nfa[0], end_state]

    return start_state, end_state

def printStateTransitions(state, states_done, symbol_table):
    if state in states_done:
        return

    states_done.append(state)

    for symbol in list(state.next_state):
        line_output = "q" + str(symbol_table[state]) + "\t\t" + symbol + "\t\t\t"
        for ns in state.next_state[symbol]:
            if ns not in symbol_table:
                symbol_table[ns] = 1 + sorted(symbol_table.values())[-1]
            line_output = line_output + "q" + str(symbol_table[ns]) + " "

        print(line_output)

        for ns in state.next_state[symbol]:
            printStateTransitions(ns, states_done, symbol_table)

def printTransitionTable(finite_automata):
    print("State\tSymbol\tNext state")
    printStateTransitions(finite_automata[0], [], {finite_automata[0]:0})


r = input("Enter regex: ")
pr = postfix(r)
et = constructTree(pr)

#inorder(et)

fa = evalRegex(et)
printTransitionTable(fa)





turing ---


transitions = [[1,5,4,5,3], 
              [1,2,5,5,1],
              [2,5,5,0,2],
              [5,5,4,5,3],
              [4,4,4,4,4],
              [5,5,5,5,5]]

symbols = ["0","1"," ","x","y"]

pointer = [[1,1,0,1,1], [1,0,1,1,1],
           [0,1,1,1,0], 
           [1,1,0,1,1],
           [1,1,1,1,1],
           [1,1,1,1,1]]
           
replace = [[3,3,3,3,4], [0,4,3,3,4],
           [0,3,3,3,4],
           [0,1,2,3,4],
           [0,1,2,3,4],
           [0,1,2,3,4]]
           
state = 0

s = input("enter the string: ")
s = list(s + " ")

acc = 4
dec = 5 

tape = s
head = 0
i = 20

print("Tape: ", end="")
print(tape)
print("State = "+str(state) + ", Head = "+ str(head))

while state < 4:
  c = state
  
  symbol = symbols.index(tape[head]) # get index of symbol
  
  tape[head] = symbols[replace[c][symbol]] 
  state = transitions[c][symbol]
  
  if pointer[c][symbol] == 0:
    head -= 1
  else:
    head += 1
    
  print("Tape: ", end="")
  print(tape)
  
  print("State = "+str(state) + ", Head = "+ str(head))
  
  if state == 4:
    print("the given string passes")
  else:
    print("the given string does not pass")





























Smis




	1.	Mean , median , mode

def calculate_mean(numbers):
    return sum(numbers) / len(numbers)

def calculate_median(numbers):
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    if n % 2 == 0:
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    else:
        median = sorted_numbers[n // 2]
    
    return median

def calculate_mode(numbers):
    frequency = {}
    
    for num in numbers:
        frequency[num] = frequency.get(num, 0) + 1
    
    max_freq = max(frequency.values())
    mode = [key for key, value in frequency.items() if value == max_freq]
    
    return mode

# Input the data
data = [int(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the mean, median, and mode
mean_value = calculate_mean(data)
median_value = calculate_median(data)
mode_value = calculate_mode(data)

print(f"Mean: {mean_value}")
print(f"Median: {median_value}")
print(f"Mode: {mode_value}")



	1.	GM, HM

def calculate_geometric_mean(numbers):
    product = 1
    
    for num in numbers:
        product *= num
    
    geometric_mean = product**(1/len(numbers))
    return geometric_mean

def calculate_harmonic_mean(numbers):
    reciprocal_sum = sum(1/num for num in numbers)
    
    harmonic_mean = len(numbers) / reciprocal_sum
    return harmonic_mean

# Input the data
data = [float(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the geometric and harmonic mean
geometric_mean_value = calculate_geometric_mean(data)
harmonic_mean_value = calculate_harmonic_mean(data)

print(f"Geometric Mean: {geometric_mean_value}")
print(f"Harmonic Mean: {harmonic_mean_value}")






Skewness


def calculate_mean(numbers):
    return sum(numbers) / len(numbers)

def calculate_median(numbers):
    sorted_numbers = sorted(numbers)
    n = len(sorted_numbers)
    
    if n % 2 == 0:
        mid1 = sorted_numbers[n // 2 - 1]
        mid2 = sorted_numbers[n // 2]
        median = (mid1 + mid2) / 2
    else:
        median = sorted_numbers[n // 2]
    
    return median

def calculate_standard_deviation(numbers, mean_value):
    n = len(numbers)
    squared_diff = sum((x - mean_value)**2 for x in numbers)
    variance = squared_diff / n
    std_deviation = variance**0.5
    return std_deviation

def calculate_karl_pearson_skewness(numbers):
    mean_value = calculate_mean(numbers)
    median_value = calculate_median(numbers)
    std_deviation = calculate_standard_deviation(numbers, mean_value)

    skewness = 3 * (mean_value - median_value) / std_deviation
    return skewness

# Input the data
data = [float(x) for x in input("Enter the space-separated numbers: ").split()]

# Calculate and print the Karl Pearson skewness
skewness_value = calculate_karl_pearson_skewness(data)

print(f"Karl Pearson Skewness: {skewness_value:.4f}")




Chi 


Chi square


data = []
for i in range(int(input("Enter the number of terms: "))):
    ob = int(input(f"Enter the observed frequency {i + 1}: "))
    ex = int(input(f"Enter the expected frequency {i + 1}: "))
    data.append((ob, ex))

print("Items:", data)

chi = 0
for o, e in data:
    chi += ((o - e) ** 2 / e)

print("Calculated Chi-square:", chi)

critical_value = float(input("Enter the critical value for chi-square test: "))

if chi > critical_value:
    print("Reject the null hypothesis")
else:
    print("Accept the null hypothesis")







2. chi



c_value = float(input("Enter the critical value : "))
terms=int(input("Enter the number of terms: "))
attributes=int(input("Enter the number of attributes: "))
data_list = []
for i in range(attributes):
    print(f'Enter value for attribute {i+1}:')
    row = []
    for j in range(terms):
        num = float(input(f'Enter term {j+1} for attribute {i+1} : '))
        row.append(num)
    data_list.append(row)
print(data_list)
        
horizontal_sum = []
for i in range(terms):
    tot = 0
    for j in range(attributes):
        tot += data_list[j][i]
    horizontal_sum.append(tot)
    
vertical_sum = []
for i in range(attributes):
    pot = 0
    for j in range(terms):
        pot+= data_list[i][j]
    vertical_sum.append(pot)
print(vertical_sum)

total_sum = sum(horizontal_sum)

expected_value = []
for i in range(attributes):
    row1 = []
    for j in range(terms):
        exp = (vertical_sum[i]*horizontal_sum[j])/total_sum
        row1.append(exp)
    expected_value.append(row1)
    
output_list = []
for i in range(attributes):
    
    for j in range(terms):
        exp = (((data_list[i][j])-expected_value[i][j])**2)/expected_value[i][j]
        
    output_list.append(exp)
final_output = sum(output_list)
print(f'The chi square value of the given dataset is {final_output}')
if(final_output>c_value):
    print('Null rejected, Alternate accepted')
else:
    print('Null not rejected, alternate rejected')


























GT



#HAVELS HAKIMI 		3

def havel_hakimi_algorithm(degree_sequence):
    # Sort the degree sequence in non-increasing order
    degree_sequence.sort(reverse=True)

    # Continue the algorithm until the degree sequence is empty or negative
    while degree_sequence:
        # Remove the first element (highest degree) from the sequence
        highest_degree = degree_sequence.pop(0)

        # Check if the remaining sequence is long enough
        if highest_degree > len(degree_sequence):
            print("Degree sequence cannot be realized as a graph.")
            return

        # Subtract 1 from the next 'highest_degree' elements in the sequence
        for i in range(highest_degree):
            degree_sequence[i] -= 1

        # Sort the sequence again in non-increasing order
        degree_sequence.sort(reverse=True)

    print("Degree sequence can be realized as a graph.")

# Example usage:
degree_sequence = [4, 3, 3, 2, 2, 1, 1, 1]
havel_hakimi_algorithm(degree_sequence)

# Dijkstras shortest path   expt 4
from queue import PriorityQueue

graph = [
    [0, 4, 0, 0, 0, 0, 0, 8, 0],
    [4, 0, 8, 0, 0, 0, 0, 11, 0],
    [0, 8, 0, 7, 0, 4, 0, 0, 2],
    [0, 0, 7, 0, 9, 14, 0, 0, 0],
    [0, 0, 0, 9, 0, 10, 0, 0, 0],
    [0, 0, 4, 14, 10, 0, 2, 0, 0],
    [0, 0, 0, 0, 0, 2, 0, 1, 6],
    [8, 11, 0, 0, 0, 0, 1, 0, 7],
    [0, 0, 2, 0, 0, 0, 6, 7, 0],
]
v = 9  # no of vertices
u = (0, 0)  # current vertex
s = 0  # source
s = int(input("Enter Source: "))
vis = [False] * v
ans = [100000] * v
ans[s] = 0
q = PriorityQueue()
q.put((0, s))  # dist,vertex
while not (q.empty()):
    u = q.get()
    if vis[u[1]]:
        continue
    vis[u[1]] == True
    for i in range(v):
        vertex = i
        dist = graph[u[1]][i]
        if ans[vertex] > ans[u[1]] + dist and dist != 0:
            ans[vertex] = ans[u[1]] + dist
            q.put((ans[vertex], vertex))
for i in range(v):
    print(s, "-->", i, "=", ans[i])


# prims algorithm     5
from queue import PriorityQueue

graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0],
]
v = 5
ans = 0
vis = [False] * v
q = PriorityQueue()
q.put((0, (0, 0)))  # dist,svertex,dvertex
print("Edge\tDistance")
while not (q.empty()):
    u = q.get()
    if vis[u[1][0]]:
        continue
    vis[u[1][0]] = True
    ans += u[0]
    if u[1] != (0, 0):
        print(u[1][0], "-->", u[1][0], "=", u[0])
    for i in range(v):
        if graph[u[1][0]][i] != 0:
            vertex = i
            dist = graph[u[1][0]][i]
            q.put((dist, (vertex, u[1][0])))

print("Minimum cost=", ans)



# Kruskal's Algorithm         	6
from queue import PriorityQueue

def find(p, x):
    if p[x] == x:
        return x
    return find(p, p[x])

def union(p, x, y):
    rx = find(p, x)
    ry = find(p, y)
    if rx == ry:
        return
    p[ry] = rx

graph = []
v = 9
v = int(input("Enter no of Vertices:"))
for i in range(v):
    r = []
    for j in range(v):
        r.append(int(input()))
    graph.append(r)
ans = 0
count = 1
p = list(range(0, v))
q = PriorityQueue()
for i in range(v):
    for j in range(v):
        if graph[i][j] != 0:
            q.put((graph[i][j], i, j))  # dist,source,desti
            graph[j][i] = 0
print("Edges\t\t Distance")
while count < v:
    u = q.get()
    rx = find(p, u[1])
    ry = find(p, u[2])
    if rx != ry:
        union(p, rx, ry)
        ans += u[0]
        print(u[1], "-->", u[2], "\t", u[0])
        count += 1
print("Minimum cost=", ans)



# BFS				7
import queue
myqueue=queue.Queue()
graph = []
v = int(input("Enter no of Vertices:"))
vis=[False]*v
for i in range(v):
    r = []
    for j in range(v):
        r.append(int(input()))
    graph.append(r)
start=int(input("enter start vertex:"))
myqueue.put(start)
print("BFS:",end="")
while not(myqueue.empty()):
    cur=myqueue.get()
    if vis[cur]:
        continue
    vis[cur]=True
    print(cur,end=" ")
    for i in range(v):
        if graph[cur][i]!=0 and not(vis[i]):
            myqueue.put(i)
print("")


# DFS			8
stack=[]
graph = []
i=0
v = int(input("Enter no of Vertices:"))
vis=[False]*v
for i in range(v):
    r = []
    for j in range(v):
        r.append(int(input()))
    graph.append(r)
start=int(input("enter start vertex:"))
stack.append(start)
print("DFS:",end="")
while len(stack)!=0:
    cur=stack.pop()
    if vis[cur]:
        continue
    vis[cur]=True
    print(cur,end=" ")
    i=v-1
    while i>=0:
        if graph[cur][i]!=0 and not(vis[i]):
            stack.append(i)
        i=i-1
print("")


#Graph Colouring				9
class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]

    def is_safe(self, v, c, color, result):
        for i in range(self.vertices):
            if self.graph[v][i] == 1 and color[i] == c:
                return False
        return True

    def graph_coloring_util(self, m, color, v, result):
        if v == self.vertices:
            return True

        for c in range(1, m + 1):
            if self.is_safe(v, c, color, result):
                color[v] = c
                if self.graph_coloring_util(m, color, v + 1, result):
                    return True
                color[v] = 0

    def get_graph_input(self):
        print("Enter the adjacency matrix:")
        for i in range(self.vertices):
            row = list(map(int, input().split()))
            self.graph[i] = row

    def graph_coloring(self):
        m = 1  # Start with 1 color
        color = [0] * self.vertices
        result = []

        while True:
            if self.graph_coloring_util(m, color, 0, result):
                break
            m += 1

        print(f"Chromatic Number: {m}")
        print("Vertex Colors:", color)

# Get user input for the number of vertices
num_vertices = int(input("Enter the number of vertices: "))
g = Graph(num_vertices)

# Get user input for the adjacency matrix
g.get_graph_input()

# Perform graph coloring and print the result
g.graph_coloring()

'''
0 1 1 0 0 0 0 0 1
1 0 0 1 0 0 0 0 1
1 0 0 0 1 0 0 0 1
0 1 0 0 0 1 0 0 0
0 0 1 0 0 0 1 0 0
0 0 0 1 0 0 0 1 1
0 0 0 0 1 0 0 1 1
0 0 0 0 0 1 1 0 1
1 1 1 0 0 1 1 1 0
'''


#TSP						10
n = int(input("Enter the total no of nodes:\n"))
matrix = [[0] * n for _ in range(n)]
visited = [0] * n
cost = 0

def tsp(c):
    global cost
    nearest, min_val, temp = 999, 999, 0
    for i in range(n):
        if matrix[c][i] != 0 and visited[i] == 0:
            if matrix[c][i] < min_val:
                min_val = matrix[c][i]
                temp = matrix[c][i]
                nearest = i
    if min_val != 999:
        cost += temp
    return nearest

def minimum_cost(city):
    global cost
    nearest = tsp(city)
    visited[city] = 1
    print(city + 1, end=" ")

    if nearest == 999:
        nearest = 0
        print(nearest + 1)
        cost += matrix[city][nearest]
        return

    minimum_cost(nearest)

print("Enter the adjacency matrix:")
for i in range(n):
    matrix[i] = list(map(int, input().split()))

print("\nPath:", end=" ")
minimum_cost(0)
print("\nThe total cost:", cost)



'''
0 5 4 0 0 0 0 0 3
5 0 0 3 0 0 0 0 1
4 0 0 0 3 0 0 0 1
0 3 0 0 0 8 0 0 2
0 0 3 0 0 0 0 9 2
0 0 0 8 0 0 10 0 7
0 0 0 0 0 10 0 11 7
0 0 0 0 9 0 11 0 7
3 1 1 2 2 7 7 7 0
'''










